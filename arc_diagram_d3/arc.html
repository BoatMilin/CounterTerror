<!-- python -m SimpleHTTPServer 8080 //-->
<!-- TODO: Convert reusable chart approach. //-->

<!DOCTYPE html>
<head>
<!--<meta http-equiv="refresh" content="3" >-->
<meta charset="utf-8">
<title>COUNTERTERROR</title>

<!-- JavaScript Libraries //-->
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="d3.slider.js"></script>   

<!-- CSS Style //-->
<link href="style.css" rel="stylesheet" type="text/css">
<link href="d3.slider.css" rel="stylesheet" type="text/css" media="screen" />       <!-- Third party -->
<script>
/* GLOBALS */
var WIDTH  = 960;           // width of svg image
var HEIGHT = 700;           // height of svg image
var MARGIN = 20;            // amount of margin around plot area
var PAD = MARGIN / 2;       // actual padding amount
var RADIUS = 30;             // fixed node radius
var Y_FIXED = PAD + RADIUS + 500;  // y position for all nodes
var DEFAULT_YEAR = 2008 // START_YEAR
var GRAPH = null;
var FILTER_GROUP = null;
var FILTER_NODE = null;
var SLIDE_UPDATE_INTERVAL = 1200;

var groupingNameMap = {
    1: "Americas",
    2: "Africa/Middle East",
    3: "Asia",
    4: "Oceania & Australia",
    5: "Europe"
}

var logScale = d3.scale.log()
                    .domain([1e-6, 10, 50, 100, 200, 300, 400, 500, 600])
                    .range([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

/* HELPER FUNCTIONS */
// Generates a tooltip for a SVG circle element based on its ID
function getYearSelectedOption(){
      var node = d3.select('#dropDown').node();
      var i = node.selectedIndex;
      return node[i].value;    
}

function addTooltip(circle) {
    var x = parseFloat(circle.attr("cx"));
    var y = parseFloat(circle.attr("cy"));
    var r = parseFloat(circle.attr("r"));
    var text = circle.attr("id");

    var tooltip = d3.select("#plot")
        .append("text")
        .text(text)
        .attr("x", x)
        .attr("y", y + 130)
        .attr("dy", -r * 2)
        .attr("id", "tooltip");

    var offset = tooltip.node().getBBox().WIDTH / 2;

    if ((x - offset) < 0) {
        tooltip.attr("text-anchor", "start");
        tooltip.attr("dx", -r);
    }
    else if ((x + offset) > (WIDTH - MARGIN)) {
        tooltip.attr("text-anchor", "end");
        tooltip.attr("dx", r);
    }
    else {
        tooltip.attr("text-anchor", "middle");
        tooltip.attr("dx", 0);
    }
}

/* MAIN DRAW METHOD */
// Draws an arc diagram for the provided undirected graph
function arcDiagram(graph) {
    // create svg image
    var svg  = d3.select("body")
        .append("svg")
        .attr("id", "arc")
        .attr("width", WIDTH)
        .attr("height", HEIGHT);

    // create plot area within svg image
    var plot = svg.append("g")
        .attr("id", "plot")
        .attr("transform", "translate(" + PAD + ", " + (PAD - 170)+ ")");

    // fix graph links to map to objects instead of indices    
    for(var key in graph.links){
        graph.links[key].forEach(function(d, i) {
            d.source = isNaN(d.source) ? d.source : graph.nodes[d.source];
            d.target = isNaN(d.target) ? d.target : graph.nodes[d.target];
        });
    }
    
    GRAPH = graph;
    linearLayout(graph.nodes);

    drawArcNodes(graph.nodes, graph.links[DEFAULT_YEAR]);
    drawLinks(graph.links[DEFAULT_YEAR]);
}

// Layout nodes linearly, sorted by group
function linearLayout(nodes) {
    // sort nodes by group
    nodes.sort(function(a, b) {
        return a.group - b.group;
    })

    // used to scale node index to x position
    var xscale = d3.scale.linear()
        .domain([0, nodes.length - 1])
        .range([RADIUS, WIDTH - MARGIN - RADIUS]);

    // calculate pixel location for each node
    nodes.forEach(function(d, i) {
        d.x = xscale(i);
        d.y = Y_FIXED;
    });
}

function drawColorScale(){
    var body = d3.select("body")
    length = 100,
    color = d3.scale.linear().domain([1,length])
      .interpolate(d3.interpolateHcl)
      .range([d3.rgb("#007AFF"), d3.rgb('#FFF500')]);

  for (var i = 0; i < length; i++) {
    body.append('div').attr('style', function (d) {
      return 'background-color: ' + color(i);
    });
  }
}

function drawInternalArcs(nodeDiv, nodes, links) {
    var internalArc = d3.svg.arc()
            .innerRadius(10)    // Scale Internal Attack
            .outerRadius(RADIUS)
            .startAngle(Math.PI/2)      
            .endAngle(Math.PI*3/2);

    // in order to draw internal arc, we have to distinguish internal attacks
    var internalAttackPerRegionMap = getInternalAttackCountMap(links)

    nodeDiv    
            .append("path")
            .attr("class", "node")
            .attr("d", function(d, i) { 
                if (d.name in internalAttackPerRegionMap) {
                    return internalArc.innerRadius(RADIUS - logScale(internalAttackPerRegionMap[d.name]))(d, i); 
                }
                return internalArc.innerRadius(RADIUS)(d, i);
            })
            .attr("id", function(d, i) { return d.name; })
            .attr("transform", function(d, i) { return translateD(d)})
            .attr("cx", function(d, i) { return d.x; })
            .attr("cy", function(d, i) { return d.y; })
            .attr("r",  function(d, i) { return RADIUS; })
            .style("fill", "black")
            .text(function(d){ addTooltip(d3.select(this))})
            .on("click", function(d, i) { console.log("node " + d + " clicked")})
    
}

function getInternalAttackCountMap(links) {
    var internalAttackPerRegionMap = {}

    for (var link of links) {
        if (link.source.name == link.target.name) {
            internalAttackPerRegionMap[link.source.name] = link.value;
        }
    }

    return internalAttackPerRegionMap
}

function getExternalAttackSourceCountMap(links) {
    var map = {}

    for (var link of links) {
        if (link.source.name != link.target.name) {
            if (link.source.name in map) {
                map[link.source.name] = map[link.source.name] + link.value;
            } else {
                map[link.source.name] = link.value;
            }
        }
    }
    return map
}

function getExternalAttackTargetCountMap(links) {
    var map = {}

    for (var link of links) {
        if (link.source.name != link.target.name) {
            if (link.target.name in map) {
                map[link.target.name] = map[link.target.name] + link.value;
            } else {
                map[link.target.name] = link.value;
            }
        }
    }
    return map
}

function drawGroupingBrackets(nodeDiv, nodes) {
    var groupingPoints = getGroupingPoints(nodes);

    /*
        Since we don't have a separate div for grouping,
        this is a horrible hack for drawing grouping lines 
        - since this will draw the same line multiple times
    */
    nodeDiv
        .append("line")
        .attr("class", function(d) { return d.group + " grouping" })
        .style("stroke", "black")
        .style("stroke-width", 4)
        .attr("x1", function(d) {
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return groupingPoints[d.group]['x1']
        })
        .attr("y1", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return d.y + 100;
        })
        .attr("x2", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return groupingPoints[d.group]['x2']
        })
        .attr("y2", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return d.y + 100;
        })
        .on("click", function(d, i) {
            if (FILTER_GROUP == d.group) {
                FILTER_GROUP = null
            } else {
                FILTER_GROUP = d.group;    
            }
            
            redrawArcs();
        });
    
    // also a horrible hack for drawing square brackets
    nodeDiv
        .append("line")
        .attr("class", function(d) { return d.group + " grouping" })
        .style("stroke", "black")
        .style("stroke-width", 5)
        .attr("x1", function(d) {
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return groupingPoints[d.group]['x1']
        })
        .attr("y1", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return d.y + 90;
        })
        .attr("x2", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return groupingPoints[d.group]['x1']
        })
        .attr("y2", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return d.y + 102;
        })
        .on("click", function(d, i) {
            if (FILTER_GROUP == d.group) {
                FILTER_GROUP = null
            } else {
                FILTER_GROUP = d.group;    
            }
            
            redrawArcs();
        });

    nodeDiv
        .append("line")
        .attr("class", function(d) { return d.group + " grouping" })
        .style("stroke", "black")
        .style("stroke-width", 5)
        .attr("x1", function(d) {
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return groupingPoints[d.group]['x2']
        })
        .attr("y1", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return d.y + 90;
        })
        .attr("x2", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return groupingPoints[d.group]['x2']
        })
        .attr("y2", function(d) { 
            if (!(d.group in groupingPoints)) {
                return 0;
            }
            return d.y + 102;
        })
        .on("click", function(d, i) {
            if (FILTER_GROUP == d.group) {
                FILTER_GROUP = null
            } else {
                FILTER_GROUP = d.group;    
            }
            
            redrawArcs();
        });

    nodeDiv
        .append("text")
        .attr("class", function(d) { return d.group + " grouping"})
        .text(function(d) { return groupingNameMap[d.group] })
        .attr("x", function(d) {
            if (!(d.group in groupingPoints)) {
                return -100;
            }
            return (groupingPoints[d.group]['x1'] + groupingPoints[d.group]['x2'])/2
        })
        .attr("y", function(d) {
            if (!(d.group in groupingPoints)) {
                return -100;
            }

            return d.y + 120;
        })
        .attr("text-anchor", "middle")
        .attr("font-size", 10)
        .on("click", function(d, i) {
            if (FILTER_GROUP == d.group) {
                FILTER_GROUP = null
            } else {
                FILTER_GROUP = d.group;    
            }
            
            redrawArcs();
        });
}

function drawArcNodes(nodes, links) {
    var atkSrcArc = d3.svg.arc()
        .innerRadius(0)   
        .outerRadius(RADIUS)
        .startAngle(0) //converting from degs to radians
        .endAngle(Math.PI/2)
    
    var atkTargetArc = d3.svg.arc()
        .innerRadius(0) 
        .outerRadius(RADIUS)
        .startAngle(3*Math.PI/2) //converting from degs to radians
        .endAngle(2*Math.PI) 

    var nodeDiv = d3.select("#plot").selectAll(".node")
        .data(nodes)
        .enter();

    
    var atkSrcColorScale = d3.scale.linear()
                    .domain([1e-6, 10, 50, 100, 200, 300, 400, 500, 600])
                    .interpolate(d3.interpolateHcl)
                    .range([
                        d3.rgb("#FDB47B"), 
                        d3.rgb("#FD984D"), 
                        d3.rgb("#DC651C"), 
                        d3.rgb("#FD812C"), 
                        d3.rgb("#BB5616"),
                        d3.rgb("#ba500d"),
                        d3.rgb("#a34408"),
                        d3.rgb("#8c3802")
                    ]);

    var atkTargetColorScale = d3.scale.linear()
                    .domain([1e-6, 10, 50, 100, 200, 300, 400, 500, 600])
                    .interpolate(d3.interpolateHcl)
                    .range([
                        d3.rgb("#C8EAE5"), 
                        d3.rgb("#83CEC1"), 
                        d3.rgb("#4FAE9E"), 
                        d3.rgb("#3A978F"), 
                        d3.rgb("#0C665E"),
                        d3.rgb("#065951"),
                        d3.rgb("#04514a"),
                        d3.rgb("#014c45")
                    ]);

    var atkSrcCountMap = getExternalAttackSourceCountMap(links)
    var atkTargetCountMap = getExternalAttackTargetCountMap(links)
    nodeDiv                         // started 
        .append("path")
        .attr("class", "node")
        .attr("d", atkSrcArc)
        .attr("id", function(d, i) { return d.name; })
        .attr("transform", function(d, i) { return translateD(d)})
        .attr("r",  function(d, i) { return RADIUS; })
        .style("fill", function(d, i) { 
            if (d.name in atkSrcCountMap) {
                return atkSrcColorScale(atkSrcCountMap[d.name]) 
            } 
            return "#ffcfaa";
        })
       
    nodeDiv                         
        .append("path")
        .attr("class", "node")
        .attr("d", atkTargetArc)
        .attr("id", function(d, i) { return d.name; })
        .attr("transform", function(d, i) { return translateD(d)})
        .attr("r",  function(d, i) { return RADIUS; })
        .style("fill", function(d, i) {
            if (d.name in atkTargetCountMap) {
                return atkTargetColorScale(atkTargetCountMap[d.name]) 
            } 
            return "#d5efeb";
        })

    
    drawInternalArcs(nodeDiv, nodes, links);
    drawGroupingBrackets(nodeDiv, nodes);
}

// assumes that nodes are sorted by grouping
// Also a horrible hack to work with Oceania & Australia
function getGroupingPoints(nodes) {
    var currentGroup = 0;
    var tmpStartPoint = 0;
    var tmpEndPoint = 0;
    var tmpGroupCount = 0;
    var groupingPoints = {}

    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i]

        tmpGroupCount++;
        if (i == 0) {
            tmpStartPoint = node.x;
            currentGroup = node.group;
            tmpGroupCount++;
        } else if (i == nodes.length - 1) {
            groupingPoints[currentGroup] = {
                "x1": tmpStartPoint,
                "x2": node.x
            };
        } else if (currentGroup != node.group) {

            if (tmpGroupCount != 1) {
                groupingPoints[currentGroup] = {
                    "x1": tmpStartPoint,
                    "x2": tmpEndPoint
                };
            }             tmpGroupCount = 0;
            tmpStartPoint = node.x;
            currentGroup = node.group
        }
        tmpEndPoint = node.x;
    }

    return groupingPoints
}

function translateD(d) {
    return "translate(" + d.x + "," + (d.y+30) + ")";
}

function drawInternalArc(links){
    var vis = d3.select("body").append("svg").attr("width", 400).attr("height", 400);

    var MAX_RADIUS = 25
    var linearScale = d3.scale.linear().domain([18979, 0]).range([10, MAX_RADIUS]);

    // uncomment for debugging
    /*
    for(var i = 0; i < links.length;i++){
        if(links[i].source.name === links[i].target.name){
            console.log(links[i].value + ' -> ' + linearScale(links[i].value));
        }
    }
    */ 
}

// Draws nodes on plot
function drawNodes(nodes) {
    // used to assign nodes color by group
    var color = d3.scale.category20();

    d3.select("#plot").selectAll(".node")
        .data(nodes)
        .enter()
        .append("circle")
        .attr("class", "node")
        .attr("id", function(d, i) { return d.name; })
        .attr("cx", function(d, i) { return d.x; })
        .attr("cy", function(d, i) { return d.y; })
        .attr("r",  function(d, i) { return RADIUS; })
        .style("fill",   function(d, i) { return color(d.group); })
        .on("mouseover", function(d, i) { addTooltip(d3.select(this)); })
        .on("mouseout",  function(d, i) { d3.select("#tooltip").remove(); })
        .on("click", function(d, i) { console.log("node " + d + " clicked")});

}

// Draws nice arcs for each link on plot
function drawLinks(links) {
    // scale to generate radians (just for lower-half of circle)
    var radians = d3.scale.linear()
        .range([-Math.PI / 2, Math.PI / 2]);

    // path generator for arcs (uses polar coordinates)
    var arc = d3.svg.line.radial()
        .interpolate("basis")
        .tension(0)
        .angle(function(d) { 
            return radians(d); 
        });

    // add links                    
    var colorScale = d3.scale.linear()
                    .domain([1e-6, 10, 50, 100, 200, 300, 400, 500, 600])
                    .interpolate(d3.interpolateHcl)
                    .range([
                        d3.rgb("#bdbdbd"), 
                        d3.rgb("#969696"), 
                        d3.rgb("#737373"), 
                        d3.rgb("#525252"), 
                        d3.rgb("#bdbdbd"), 
                        d3.rgb("#252525"), 
                        d3.rgb("#000000")]);

    filteredLinks = links
    if (FILTER_GROUP != null) {
        filteredLinks = filterLinksByGroup(links);
    }
    
    d3.select("#plot").selectAll(".link")
        .data(filteredLinks)
        .enter()
        .append("path")
        .attr("class", "link")
        .style("stroke-width", function(d){
            if(d.value === 1){          // dotted line
                return d.value;
            }else{
                return(logScale(d.value));
            }
        }) 
        .style("stroke", function(d) { 
            return colorScale(d.value);
        })
        .attr("transform", function(d, i) {
            // arc will always be drawn around (0, 0)
            // shift so (0, 0) will be between source and target
            var xshift = d.source.x + (d.target.x - d.source.x)/2;
            var yshift = Y_FIXED;
            return "translate(" + xshift + ", " + yshift + ")";
        })
        .attr("d", function(d, i) {
            // get x distance between source and target
            var xdist = Math.abs(d.source.x - d.target.x);
            // set arc radius based on x distance

            if (d.source.x < d.target.x) {
                arc.radius((xdist + RADIUS)/ 2);
            } else {
                arc.radius((xdist - RADIUS)/ 2);
            }

            // want to generate 1/3 as many points per pixel in x direction
            var points = d3.range(0, Math.ceil(xdist / 3));
            // set radian scale domain
            radians.domain([0, points.length - 1]);
            // return path for arc
            return arc(points);
        });
}

function updateYearFromSlider(slider) {
    var year = slider.value();
    updateYear(year);
}

function updateYear(year) {
    d3.select("#plot").selectAll(".link").remove();
    d3.select("#plot").selectAll(".node").remove();
    drawLinks(GRAPH.links[year])
    drawArcNodes(GRAPH.nodes, GRAPH.links[year])
}

function incrementSlider() {
    if (isPlaying) {
        var sliderValue = slider.value();
        if (sliderValue == slider.max()) {
            slider.setValue(slider.min());
        } else {
            slider.setValue(++sliderValue);
        }
    } 
}

function redrawArcs() {
    updateYearFromSlider(slider);
}

function filterByGroup(group) {
    if (group == FILTER_GROUP) {
        FILTER_GROUP = null;
    } else {
        FILTER_GROUP = group    
    }

    console.log(FILTER_GROUP)
    
}

// TODO: figure out a way to get this called
function clearFiltering() {
    FILTER_NODE = null;
    FILTER_GROUP = null;
}

function filterLinksByGroup(links) {
    var filteredLinks = []
    for (link of links) {
        if (link.source.group == FILTER_GROUP || link.target.group == FILTER_GROUP) {
            filteredLinks.push(link)
        }
    }

    return filteredLinks;
}

</script>
</head>
<body>
<div>
    <div class="playpause" style="width: 15%; height: 100%;">
        <input type="checkbox" value="None" id="playpause" name="check" checked/>
        <label id="play" for="playpause" tabindex=1 style=" margin-top: 15px"></label>
    </div>
    <div id="slider" style="float: left;"></div>
</div>

<script>
d3.json("terror_by_year.json", arcDiagram);

var tickFormatter = function(d) {
    return d;
}

var slider = d3.slider().min(DEFAULT_YEAR).max(2016).tickValues([2008,2009,2010,2011,2012,2013,2014,2015,2016]).stepValues([2008,2009,2010,2011,2012,2013,2014,2015,2016]).tickFormat(tickFormatter);

slider.callback(updateYearFromSlider);
d3.select('#slider').call(slider);

var isPlaying = false;
document.getElementById("play").addEventListener("click", function() {
    isPlaying = !isPlaying;
});
setInterval(incrementSlider, SLIDE_UPDATE_INTERVAL);
// setInterval(redrawArcs, 400)
// hack to wait for the browser to finish drawing everything
</script>
</body>
</html>